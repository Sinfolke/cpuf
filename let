#pragma once

#ifndef CPUF_LET
#define CPUF_LET
#include "versions"
#include "color"

#if !CXX11
#error "cpuf/let requires cxx11"
#endif

#include <string>
#include <cstring>
#include <type_traits>
#include <iostream>
#include <cmath>
#include <istream>
#include <memory>

#include <cctype>

#if CXX17
#include <charconv>
#endif 

#ifdef CPUF_LET_PUBLICNULL
#define PRIVATE 
#define ENDPRIV 
#else
#define PRIVATE namespace {
#define ENDPRIV }
#endif

/**
 * @brief Checks whether the given _type is a string _type
 * 
 * This structure is used to check whether the given _type is a string _type (char*, std::string, char [N]).
 *
 * @tparam T The _type to be checked
 * @return A boolean value that is true if the _type is a string _type, and false otherwise.
 */
template <typename T> struct is_string {
    static const bool value = false;
};

template <> struct is_string<char> {
    static const bool value = true;
};

// Specialization for char*
template <> struct is_string<char*> {
    static const bool value = true;
};

// Specialization for std::string
template <> struct is_string<std::string> {
    static const bool value = true;
};

// Specialization for char[]
template <size_t N> struct is_string<char[N]> {
    static const bool value = true;
};

class unexpected__type_exception : std::exception {
    public:
    unexpected__type_exception(std::string op, std::string unexpected) {
#if defined(DEBUG) || defined(CPUF_LET_DEBUG)
        std::cout << __FILE__ ": Unexpected _type \"" << unexpected << "\" on [" << op << ']' << std::endl;
#endif
    }
    unexpected__type_exception(std::string op, std::string first, std::string second, std::string expected, std::string got, bool which) {
#if defined(DEBUG) || defined(CPUF_LET_DEBUG)
        std::cout << __FILE__ ": Incompatible _types <";
        if (which == 0)
            std::cout << color::red << first << color::reset << "> " << op << " <" << second << ">: expected " << expected;
        else
            std::cout << first << "> " << op << " <" << color::red << second << color::reset << ">: expected " << expected;
#endif
    }
    virtual const char* what() const throw() {
        return __FILE__ ": Unexpected _type";
    }
};

PRIVATE 
    struct __Null {};
ENDPRIV
__Null Null;
class Type {
public:
    enum type {
        Int, Bool, Double, String, Null
    };

    Type(type t = type::Null) : _t(t) {}

    Type(const class let& data);

    operator type() const {
        return _t;
    }

    template<typename T, typename = typename std::enable_if<std::is_integral<T>::value>::type>
    operator T() const {
        return _t;
    }
    const char* str() const noexcept {
        switch (_t) {
            case type::String:
                return "String";
            case type::Int:
                return "Int";
            case type::Bool:
                return "Bool";
            case type::Double:
                return "Double";
            default:
                return "Null";            
        }
    }
    friend std::ostream& operator<<(std::ostream& out, const Type& type) {
        out << type.str();
        return out;
    }
private:
    type _t;
};
class let {
protected:
    union DATA {
        std::string str;
        long long num;
        long double fl;

        DATA() : num(0) {} // Default constructor
        ~DATA() {} // Destructor
    } data;
    Type _type;
public:
    /**
     * @brief If the data is string the str_destructor is called
     * 
     */
    void unstring() {
        if (_type == Type::String) {
            str_destructor();
        }
    }
    /**
     * @brief just directly call the string destructor
     * 
     */
    void str_destructor() {
        data.str.~basic_string();
    }
    /**
     * @brief Convert the property data to a string
     * @return std::string 
     */
    std::string toString() const noexcept {
        switch (_type) {
            case Type::Bool: return data.num ? "true" : "false";
            case Type::Int: return std::to_string(data.num);
            case Type::Double: return std::to_string(data.fl);
            case Type::String: return data.str;
            default: return "Null";
        }
    }
    /**
     * @brief Construct the std::string class with your value to data. _type is not changed
     * 
     * @tparam T
     * @param value 
     */
    template<typename T>
    inline void str_constructor(const T& value) {
        new (&data.str) std::string(value);
    }
    inline void str_constructor() {
        new (&data.str) std::string();
    }
    /**
     * @brief Construct the std::string class with your value and change the _type to Type::String
     * 
     * @tparam T
     * @param value 
     */
    template<typename T>
    inline void makeString(const T& value) {
        str_constructor(value);
        _type = Type::String;
    }

    /**
     * @brief Sets the string to desired value. If _type is not string, makeString() is called and _type set to Type::String
     * 
     * @tparam T 
     * @param value 
     */
    template <typename T>
    inline void setString(const T& value) {
        if (_type == Type::String) {
            data.str = value;
        } else {
            makeString(value);
        }
    }
    /**
     * @brief Add string if the data is already a string. Otherwise makeString( toString() + value) is called and _type set to Type::String
     * 
     * @tparam T 
     * @param value 
     */
    template<typename T>
    inline void addString(const T& value) {
        if (_type == Type::String) {
            data.str = value;
        } else {
            makeString(toString() + value);
        }
    }
    // methods

    auto type() const noexcept {
        return _type;
    }
    template<typename TYPE> TYPE cast() const;
    template<>
    int cast<int>() const {
        #ifdef DEBUG
        if (_type == Type::Bool) {
            std::cerr << "\nlet::cast<int> throws a warning: the type is bool but you're casting to int" << std::endl;
            return data.num;
        } else
        #endif
        if (_type != Type::Int) {
            throw std::runtime_error("let::cast<int> throws an error: your type is not Int");
        }
        return data.num;
    }
    template<>
    long long cast<long long>() const {
        #ifdef DEBUG
        if (_type == Type::Bool) {
            std::cerr << "\nlet::cast<long long> throws a warning: the type is bool but you're casting to int" << std::endl;
            return data.num;
        } else
        #endif
        if (_type != Type::Int) {
            throw std::runtime_error("let::cast<long long> throws an error: your type is not Int");
        }
        return data.num;
    }
    template<>
    bool cast() const {
        #ifdef DEBUG
        if (_type == Type::Int) {
            std::cerr << "\nlet::cast<bool> throws a warning: the type is int but you're casting to bool" << std::endl;
            return data.num;
        } else
        #endif
        if (_type != Type::Bool) {
            throw std::runtime_error("let::cast<bool> throws an error: your type is not Bool");
        }
        return data.num;
    }
    template<>
    double cast() const {
        if (_type != Type::Double) {
            throw std::runtime_error("let::cast<double> throws an error: your type is not Double");
        }
        return data.fl;
    }
    template<>
    std::string cast() const {
        if (_type != Type::String) {
            throw std::runtime_error("let::cast<std::string> throws an error: your type is not String");
        }
        return data.str;
    }
    template<>
    const char* cast() const {
        if (_type != Type::String) {
            throw std::runtime_error("let::cast<const char*> throws an error: your type is not String");
        }
        return data.str.c_str();
    }
    /**
     * @brief Returns a reference to the data union. Please be careful.
     * 
     * @return auto& 
     */
    auto& ref() {
        return data;
    }
    auto& reft() {
        return _type;
    }
    /**
     * @brief Assign the string element converting to the corresponding type is possible. If not the value assigned as a string type
     * 
     * @param el 
     * @return Type 
     */
    // Type convertible_assign(const char* el) {
        
    // }

    let() : _type(Type::Null) {}
    let(const __Null) : _type(Type::Null) {}

    let(long long input) : _type(Type::Int) {
        data.num = input;
    }
    let(unsigned long long input) : _type(Type::Int) {
        data.num = input;
    }
    let(long input) : _type(Type::Int) {
        data.num = input;
    }
    let(unsigned long input) : _type(Type::Int) {
        data.num = input;
    }
    let(int input) : _type(Type::Int) {
        data.num = input;
    }
    let(unsigned int input) : _type(Type::Int) {
        data.num = input;
    }
    let(short input) : _type(Type::Int) {
        data.num = input;
    }
    let(unsigned short input) : _type(Type::Int) {
        data.num = input;
    }
    let(char input) : _type(Type::Int) {
        data.num = input;
    }
    let(unsigned char input) : _type(Type::Int) {
        data.num = input;
    }
    let(long double input) : _type(Type::Double) {
        data.fl = input;
    }
    let(double input) : _type(Type::Double) {
        data.fl = input;
    }
    let(float input) : _type(Type::Double) {
        data.fl = input;
    }
    let(const std::string& input) {
        makeString(input);
    }
    let(const char* input) {
        makeString(input);
    }
    let(const let& input) {
        if (input._type == Type::String) {
            str_constructor(input.data.str);
        } else {
            data.num = input.data.num;
        }
        _type = input._type;
    }
    ~let() {
        unstring();
    }
    // Assignment operators
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator=(const T& num) {
        unstring();
        if (std::is_same<T, bool>::value)
            _type = Type::Bool;
        else
            _type = Type::Int;
        data.num = num;
        return *this;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let&>::type
    operator=(const T& input) {
        unstring();
        data.fl = static_cast<T>(input);
        _type = Type::Double;
        return *this;
    }
    template<typename T>
    std::enable_if<is_string<T>::value, let&>::type
    operator=(const T& str) {
        setString(str);
        return *this;
    }

    // Copy assignment operator
    let& operator=(const let& other) {
        if (this == &other) return *this;

        if (other._type == Type::String) {
            setString(other.data.str);
        } else {
            _type = other._type;
            data.num = other.data.num;
        }
        return *this;
    }

        // Compound assignment operators
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator+=(const T& other) {
        if (_type == Type::String) {
            data.str += other;
        } else if (_type < Type::Double) {
            data.num += other;
            _type = Type::Int;
        } else {
            data.fl += other;
        }
        return *this;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let&>::type
    operator+=(const T& other) {
        if (_type == Type::String) {
            data.str += other;
        } else if (_type < Type::Double) {
            auto fl = data.num + other;
            data.fl = fl;
            _type = Type::Double;
        } else {
            data.fl += other;
        }
        return *this;
    }
    template<typename T>
    std::enable_if<is_string<T>::value, let&>::type
    operator+=(const let& other) {
        addString(other);
        return *this;
    }
    let& operator+=(const let& other) {
        if (this == &other) return *this;
        if (other._type == Type::String) {
            makeString(toString() + other.data.str);
        } else if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num += other.data.num;
                _type = Type::Int;
            } else if (other._type == Type::Double) {
                auto fl = other.data.fl + data.num;
                data.fl = fl;
                _type = Type::Double; 
            } else {
                throw unexpected__type_exception("+=", "(INT | BOOL)", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (_type == Type::Double) {
            if (other._type < Type::Double) {
                data.fl += other.data.num;
            } else if (other._type == Type::Double) {
                data.fl += other.data.fl;
            } else {
                throw unexpected__type_exception("+=", "Double", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else if (_type == Type::String) {
            data.str += other.toString();
        } else {
            throw unexpected__type_exception("+=", _type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", _type.str(), 0);
        }
        return *this;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator-=(const T& other) {
        if (_type >= Type::String) {
            throw unexpected__type_exception("-=", _type.str(), "Int | Bool", "(INT | BOOL | DOUBLE)", _type.str(), 0);
        }
        if (_type < Type::Double) {
            data.num -= other;
            _type = Type::Int;
        } else {
            data.fl -= other;
        }
        return *this;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let&>::type
    operator-=(const T& other) {
        if (_type >= Type::String) {
            throw unexpected__type_exception("-=", _type.str(), "Int | Bool", "(INT | BOOL | DOUBLE)", _type.str(), 0);
        }
        if (_type < Type::Double) {
            double d = data.num - other;
            data.fl = d;
            _type = Type::Double;
        } else {
            data.fl -= other;
        }
        return *this;
    }
    let& operator-=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num -= other.data.num;
                _type = Type::Int;
            } else if (other._type == Type::Double) {
                auto fl = other.data.fl - data.num;
                data.fl = fl;
                _type = Type::Double; 
            } else {
                throw unexpected__type_exception("-=", "(INT | BOOL)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (_type == Type::Double) {
            if (other._type < Type::Double) {
                data.fl -= other.data.num;
            } else if (other._type == Type::Double) {
                data.fl -= other.data.fl;
            } else {
                throw unexpected__type_exception("-=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("-=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 0);
        }
        return *this;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator*=(const T& other) {
        if (_type >= Type::String) {
            throw unexpected__type_exception("*=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", "String", 0);
        }
        if (_type < Type::Double) {
            data.num *= other;
            _type = Type::Int;
        } else {
            data.fl *= other;
        }
        return *this;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let&>::type
    operator*=(const T& other) {
        if (_type >= Type::String) {
            throw unexpected__type_exception("*=", "String", "Int | Bool", "[INT | BOOL, DOUBLE]]", "String", 0);
        }
        if (_type < Type::Double) {
            double d = other * data.num;
            data.fl = d;
            _type = Type::Double;
        } else {
            data.fl *= other;
        }
        return *this;
    }
    let& operator*=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num *= other.data.num;
                _type = Type::Int;
            } else if (other._type == Type::Double) {
                auto fl = other.data.fl * data.num;
                data.fl = fl;
                _type = Type::Double; 
            } else {
                throw unexpected__type_exception("*=", "(INT | BOOL)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (_type == Type::Double) {
            if (other._type < Type::Double) {
                data.fl *= other.data.num;
            } else if (other._type == Type::Double) {
                data.fl *= other.data.fl;
            } else {
                throw unexpected__type_exception("*=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("*=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 0);
        }
        return *this;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator/=(const T& other) {
        if (_type >= Type::String) {
            throw unexpected__type_exception("/=", "String", "Int | Bool", "[INT | BOOL, DOUBLE]]", "String", 0);
        }
        if (_type < Type::Double) {
            data.num /= other;
            _type = Type::Int;
        } else {
            data.fl /= other;
        }
        return *this;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let&>::type
    operator/=(const T& other) {
        if (_type >= Type::String) {
            throw unexpected__type_exception("/=", "String", "Double", "[INT | BOOL, DOUBLE]]", "String", 0);
        }
        if (_type < Type::Double) {
            double d = other / data.num;
            data.fl = d;
            _type = Type::Double;
        } else {
            data.fl /= other;
        }
        return *this;
    }
    let& operator/=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num /= other.data.num;
                _type = Type::Int;
            } else if (other._type == Type::Double) {
                auto fl = other.data.fl / data.num;
                data.fl = fl;
                _type = Type::Double; 
            } else {
                throw unexpected__type_exception("/=", "(INT | BOOL)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (_type == Type::Double) {
            if (other._type < Type::Double) {
                data.fl /= other.data.num;
            } else if (other._type == Type::Double) {
                data.fl /= other.data.fl;
            } else {
                throw unexpected__type_exception("/=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("/=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 0);
        }
        return *this;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator%=(const T& other) {
        if (_type >= Type::String) {
            throw unexpected__type_exception("%=", "String", "Int | Bool", "[INT | BOOL, DOUBLE]]", "String", 0);
        }
        if (_type < Type::Double) {
            data.num %= other;
            _type = Type::Int;
        } else {
            data.fl = std::fmod(data.fl, other);
        }
        return *this;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let&>::type
    operator%=(const T& other) {
        if (_type >= Type::String) {
            throw unexpected__type_exception("%=", "String", "Int | Bool", "[INT | BOOL, DOUBLE]]", "String", 0);
        }
        if (_type < Type::Double) {
            data.fl = std::fmod(data.num, other);
            _type = Type::Double;
        } else {
            data.fl = std::fmod(data.fl, other);
        }
        return *this;
    }
    let& operator%=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num %= other.data.num;
                _type = Type::Int;
            } else if (other._type == Type::Double) {
                data.fl = std::fmod(data.num, other.data.fl);
                _type = Type::Double; 
            } else {
                throw unexpected__type_exception("%=", "(INT | BOOL)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (_type == Type::Double) {
            if (other._type < Type::Double) {
                data.fl = fmod(data.fl, other.data.num);
            } else if (other._type == Type::Double) {
                data.fl = fmod(data.fl, other.data.fl);
            } else {
                throw unexpected__type_exception("%=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("%=", "(DOUBLE)", "(let)", "(INT | BOOL | DOUBLE)", other._type.str(), 0);
        }
        return *this;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator>>=(const T& other) {
        if (_type >= Type::Double) {
            throw unexpected__type_exception(">>=", _type.str(), "Int | Bool", "Int | Bool", _type.str(), 0);
        }
        data.num >>= other;
        _type = Type::Int;
        return *this;
    }
    let& operator>>=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num >>= other.data.num;   
            } else {
                throw unexpected__type_exception(">>=", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception(">>=", _type.str(), other._type.str(), "Int | Bool", _type.str(), 0);
        }
        return *this;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator<<=(const T& other) {
        if (_type >= Type::Double) {
            throw unexpected__type_exception("<<=", _type.str(), "Int | Bool", "Int | Bool", _type.str(), 0);
        }
        data.num <<= other;
        _type = Type::Int;
        return *this;
    }
    let& operator<<=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num <<= other.data.num;   
            } else {
                throw unexpected__type_exception("<<=", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("<<=", _type.str(), other._type.str(), "Int | Bool", _type.str(), 0);
        }
        return *this;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator&=(const T& other) {
        if (_type >= Type::Double) {
            throw unexpected__type_exception("&=", _type.str(), "Int | Bool", "Int | Bool", _type.str(), 0);
        }
        data.num &= other;
        _type = Type::Int;
        return *this;
    }

    let& operator&=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num &= other.data.num;   
            } else {
                throw unexpected__type_exception("&=", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("&=", _type.str(), other._type.str(), "Int | Bool", _type.str(), 0);
        }
        return *this;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator|=(const T& other) {
        if (_type >= Type::Double) {
            throw unexpected__type_exception("|=", _type.str(), "Int | Bool", "Int | Bool", _type.str(), 0);
        }
        data.num |= other;
        _type = Type::Int;
        return *this;
    }
    let& operator|=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num |= other.data.num;   
            } else {
                throw unexpected__type_exception("|=", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("|=", _type.str(), other._type.str(), "Int | Bool", _type.str(), 0);
        }
        return *this;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let&>::type
    operator^=(const T& other) {
        if (_type >= Type::Double) {
            throw unexpected__type_exception("^=", _type.str(), "Int | Bool", "Int | Bool", _type.str(), 0);
        }
        data.num ^= other;
        _type = Type::Int;
        return *this;
    }
    let& operator^=(const let& other) {
        if (this == &other) return *this;
        if (_type < Type::Double) {
            if (other._type < Type::Double) {
                data.num ^= other.data.num;   
            } else {
                throw unexpected__type_exception("^=", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("^=", _type.str(), other._type.str(), "Int | Bool", _type.str(), 0);
        }
        return *this;
    }
        // Compound assignment operators
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator+(let d, const T& other) {
        if (d._type == Type::String) {
            d.data.str += other;
        } else if (d._type < Type::Double) {
            d.data.num += other;
            d._type = Type::Int;
        } else {
            d.data.fl += other;
        }
        return d;
    }
    
    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let>::type
    friend operator+(let d, const T& other) {
        if (d._type == Type::String) {
            d.data.str += other;
        } else if (d._type < Type::Double) {
            d.data.fl += other;
            d._type = Type::Double;
        } else {
            d.data.fl += other;
        }
        return d;
    }
    template<typename T>
    std::enable_if<is_string<T>::value, let>::type
    friend operator+(let d, const T& other) {
        if (d._type == Type::String) {
            d.data.str += other;
        } else {
            d.str_constructor(d.toString());
            d.data.str += other;
            d._type = Type::String;
        }
        return d;
    }
    friend let operator+(let d, const let& other) {
        if (other._type == Type::String) {
            d.makeString(d.toString() + other.data.str);
        } else if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num += other.data.num;
                d._type = Type::Int;
            } else if (other._type == Type::Double) {
                auto fl = other.data.fl + d.data.num;
                d.data.fl = fl;
                d._type = Type::Double; 
            } else {
                throw unexpected__type_exception("+", "Int | Bool", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (d._type == Type::Double) {
            if (other._type < Type::Double) {
                d.data.fl += other.data.num;
            } else if (other._type == Type::Double) {
                d.data.fl += other.data.fl;
            } else {
                throw unexpected__type_exception("+", "Double", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else if (d._type == Type::String) {
            d.data.str += other.toString();
        } else {
            throw unexpected__type_exception("+", "Null", other._type.str(), "(INT | BOOL | DOUBLE)", "Null", 0);
        }
        return d;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator-(let d, const T& other) {
        if (d._type >= Type::String) {
            throw unexpected__type_exception("-", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        if (d._type < Type::Double) {
            d.data.num -= other;
            d._type = Type::Int;
        } else {
            d.data.fl -= other;
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let>::type
    friend operator-(let d, const T& other) {
        if (d._type >= Type::String) {
            throw unexpected__type_exception("-", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        if (d._type < Type::Double) {
            d.data.fl = other - d.data.num;
            d._type = Type::Double;
        } else {
            d.data.fl -= other;
        }
        return d;
    }

    friend let operator-(let d, const let& other) {
        if (d._type >= Type::String)
            throw unexpected__type_exception("-", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        else if (other._type >= Type::String)
            throw unexpected__type_exception("-", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 1);
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num -= other.data.num;
                d._type = Type::Int;
            } else if (other._type == Type::Double) {
                auto fl = other.data.fl - d.data.num;
                d.data.fl = fl;
                d._type = Type::Double; 
            } else {
                throw unexpected__type_exception("-", "Int | Bool", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (d._type == Type::Double) {
            if (other._type < Type::Double) {
                d.data.fl -= other.data.num;
            } else if (other._type == Type::Double) {
                d.data.fl -= other.data.fl;
            } else {
                throw unexpected__type_exception("-", "Double", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("-", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator*(let d, const T& other) {
        if (d._type >= Type::String) {
            throw unexpected__type_exception("*", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        if (d._type < Type::Double) {
            d.data.num *= other;
            d._type = Type::Int;
        } else {
            d.data.fl *= other;
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let>::type
    friend operator*(let d, const T& other) {
        if (d._type >= Type::String) {
            throw unexpected__type_exception("*", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        if (d._type < Type::Double) {
            d.data.fl = other * d.data.num;
            d._type = Type::Double;
        } else {
            d.data.fl *= other;
        }
        return d;
    }

    friend let operator*(let d, const let& other) {
        if (d._type >= Type::String)
            throw unexpected__type_exception("*", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        else if (other._type >= Type::String)
            throw unexpected__type_exception("*", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 1);
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num *= other.data.num;
                d._type = Type::Int;
            } else if (other._type == Type::Double) {
                auto fl = other.data.fl * d.data.num;
                d.data.fl = fl;
                d._type = Type::Double; 
            } else {
                throw unexpected__type_exception("*", "Int | Bool", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (d._type == Type::Double) {
            if (other._type < Type::Double) {
                d.data.fl *= other.data.num;
            } else if (other._type == Type::Double) {
                d.data.fl *= other.data.fl;
            } else {
                throw unexpected__type_exception("-", "Double", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("-", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator/(let d, const T& other) {
        if (d._type >= Type::String) {
            throw unexpected__type_exception("/", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        if (d._type < Type::Double) {
            d.data.num /= other;
            d._type = Type::Int;
        } else {
            d.data.fl /= other;
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let>::type
    friend operator/(let d, const T& other) {
        if (d._type >= Type::String) {
            throw unexpected__type_exception("/", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        if (d._type < Type::Double) {
            d.data.fl = other / d.data.num;
            d._type = Type::Double;
        } else {
            d.data.fl /= other;
        }
        return d;
    }

    friend let operator/(let d, const let& other) {
        if (d._type >= Type::String)
            throw unexpected__type_exception("/", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        else if (other._type >= Type::String)
            throw unexpected__type_exception("/", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 1);
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num /= other.data.num;
                d._type = Type::Int;
            } else if (other._type == Type::Double) {
                auto fl = other.data.fl / d.data.num;
                d.data.fl = fl;
                d._type = Type::Double; 
            } else {
                throw unexpected__type_exception("/", "Int | Bool", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (d._type == Type::Double) {
            if (other._type < Type::Double) {
                d.data.fl /= other.data.num;
            } else if (other._type == Type::Double) {
                d.data.fl /= other.data.fl;
            } else {
                throw unexpected__type_exception("/", "Double", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("/", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator%(let d, const T& other) {
        if (d._type >= Type::String) {
            throw unexpected__type_exception("%", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        if (d._type < Type::Double) {
            d.data.num %= other;
            d._type = Type::Int;
        } else {
            d.data.fl = std::fmod(d.data.fl, other);
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, let>::type
    friend operator%(let d, const T& other) {
        if (d._type >= Type::String) {
            throw unexpected__type_exception("%", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        if (d._type < Type::Double) {
            d.data.fl = std::fmod(d.data.num, other);
            d._type = Type::Double;
        } else {
            d.data.fl = std::fmod(d.data.fl, other);
        }
        return d;
    }

    friend let operator%(let d, const let& other) {
        if (d._type >= Type::String)
            throw unexpected__type_exception("%", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        else if (other._type >= Type::String)
            throw unexpected__type_exception("%", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 1);
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num /= other.data.num;
                d._type = Type::Int;
            } else if (other._type == Type::Double) {
                d.data.fl = std::fmod(d.data.num, other.data.fl);
                d._type = Type::Double; 
            } else {
                throw unexpected__type_exception("%", "Int | Bool", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }

        } else if (d._type == Type::Double) {
            if (other._type < Type::Double) {
                d.data.fl = std::fmod(d.data.fl, other.data.num);
            } else if (other._type == Type::Double) {
                d.data.fl = std::fmod(d.data.fl, other.data.fl);
            } else {
                throw unexpected__type_exception("%", "Double", other._type.str(), "(INT | BOOL | DOUBLE)", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("%", d._type.str(), other._type.str(), "(INT | BOOL | DOUBLE)", d._type.str(), 0);
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator>>(let d, const T& other) {
        if (d._type >= Type::Double) {
            throw unexpected__type_exception(">>", d._type.str(), "Int | Bool", "Int | Bool", d._type.str(), 0);
        }
        d.data.num >>= other;
        d._type = Type::Int;
        return d;
    }
    friend let operator>>(let d, const let& other) {
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num >>= other.data.num;   
            } else {
                throw unexpected__type_exception(">>", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception(">>", d._type.str(), other._type.str(), "Int | Bool", d._type.str(), 0);
        }
        return d;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator<<(let d, const T& other) {
        if (d._type >= Type::Double) {
            throw unexpected__type_exception("<<", d._type.str(), "Int | Bool", "Int | Bool", d._type.str(), 0);
        }
        d.data.num <<= other;
        d._type = Type::Int;
        return d;
    }
    friend let operator<<(let d, const let& other) {
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num <<= other.data.num;   
            } else {
                throw unexpected__type_exception("<<", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("<<", d._type.str(), other._type.str(), "Int | Bool", d._type.str(), 0);
        }
        return d;
    }
    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator&(let d, const T& other) {
        if (d._type >= Type::Double) {
            throw unexpected__type_exception("&", d._type.str(), "Int | Bool", "Int | Bool", d._type.str(), 0);
        }
        d.data.num &= other;
        d._type = Type::Int;
        return d;
    }
    friend let operator&(let d, const let& other) {
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num &= other.data.num;   
            } else {
                throw unexpected__type_exception("&", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("&", d._type.str(), other._type.str(), "Int | Bool", d._type.str(), 0);
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator|(let d, const T& other) {
        if (d._type >= Type::Double) {
            throw unexpected__type_exception("|", d._type.str(), "Int | Bool", "Int | Bool", d._type.str(), 0);
        }
        d.data.num |= other;
        d._type = Type::Int;
        return d;
    }
    friend let operator|(let d, const let& other) {
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num |= other.data.num;   
            } else {
                throw unexpected__type_exception("|", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("|", d._type.str(), other._type.str(), "Int | Bool", d._type.str(), 0);
        }
        return d;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, let>::type
    friend operator^(let d, const T& other) {
        if (d._type >= Type::Double) {
            throw unexpected__type_exception("^", d._type.str(), "Int | Bool", "Int | Bool", d._type.str(), 0);
        }
        d.data.num ^= other;
        d._type = Type::Int;
        return d;
    }
    friend let operator^(let d, const let& other) {
        if (d._type < Type::Double) {
            if (other._type < Type::Double) {
                d.data.num ^= other.data.num;   
            } else {
                throw unexpected__type_exception("^", "Int | Bool", other._type.str(), "Int | Bool", other._type.str(), 1);
            }
        } else {
            throw unexpected__type_exception("^", d._type.str(), other._type.str(), "Int | Bool", d._type.str(), 0);
        }
        return d;
    }
    let& operator++() {
        if (_type < Type::Double) {
            data.num++;
        } else if (_type == Type::Double) {
            data.fl++;
        } else {
            throw std::runtime_error("let::operator++ throws an error: your type is not numeric");
        }
        return *this;
    }
    friend let operator++(let& dt, int) {
        let prev = dt;
        ++dt;
        return prev;
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T>, bool>::type
    operator==(const T& num) const noexcept {
        if (std::is_same<T, bool>::value)
            return _type == Type::Bool && data.num == num;
        else
            return _type == Type::Int && data.num == num;
        
    } 
    template<typename T>
    std::enable_if<std::is_floating_point_v<T>, bool>::type
    operator==(const T& fl) const noexcept {
        return _type == Type::Double && data.fl == fl;
        
    }
    bool operator==(const char& c) const noexcept {
        return _type == Type::String && data.str.size() == 1 && data.str[0] == c;
    }
    template<typename T>
    std::enable_if<is_string<T>::value, bool>::type
    operator==(const T& str) const noexcept {
        return _type == Type::String && data.str == str;
    }
    bool operator==(const __Null) const noexcept  {
        return _type == Type::Null;
    }


    template<typename T>
    std::enable_if<std::is_integral_v<T> || std::is_floating_point_v<T> || std::is_same<T, char>::value || is_string<T>::value || std::is_same<T, __Null>::value, bool>::type
    friend operator!=(const let& dt, const T& num) noexcept {
        return !(dt == num);
    } 

    template<typename T>
    std::enable_if<std::is_integral_v<T> || std::is_floating_point_v<T> || std::is_same<T, char>::value, bool>::type
    operator>(const T& num) const {
        if (_type < Type::Double) {
            return data.num > num;
        } else if (_type == Type::Double) {
            return data.fl > num;
        } else {
            throw std::runtime_error("let::operator> throws an error: your type is not numeric");
        }
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T> || std::is_floating_point_v<T> || std::is_same<T, char>::value, bool>::type
    operator<(const T& num) const {
        if (_type < Type::Double) {
            return data.num < num;
        } else if (_type == Type::Double) {
            return data.fl < num;
        } else {
            throw std::runtime_error("let::operator> throws an error: your type is not numeric");
        }
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T> || std::is_floating_point_v<T> || std::is_same<T, char>::value, bool>::value
    operator>=(const T& num) const {
        if (_type < Type::Double) {
            return data.num >= num;
        } else if (_type == Type::Double) {
            return data.fl >= num;
        } else {
            throw std::runtime_error("let::operator> throws an error: your type is not numeric");
        }
    }

    template<typename T>
    std::enable_if<std::is_integral_v<T> || std::is_floating_point_v<T> || std::is_same<T, char>::value, bool>::value
    operator<=(const T& num) const {
        if (_type < Type::Double) {
            return data.num <= num;
        } else if (_type == Type::Double) {
            return data.fl <= num;
        } else {
            throw std::runtime_error("let::operator> throws an error: your type is not numeric");
        }
    }

    friend std::ostream& operator<<(std::ostream& os, const let& obj) {
        #if defined(DEBUG) || defined(CPUF_LET_DEBUG)
        os << "(_type:" << obj._type.str() << ") ";
        #endif
        switch (obj._type) {
            case Type::Bool:
                os << (obj.data.num == 1 ? "true" : "false");
                break;
            case Type::Int:
                os << obj.data.num;
                break;
            case Type::Double:
                os << obj.data.fl;
                break;
            case Type::String:
                os << obj.data.str;
                break;
            case Type::Null:
                os << "Null";
                break;
        }
        return os;
    }
    template <class _Elem, class _Traits>
    friend std::basic_istream<_Elem, _Traits>& operator>>(std::basic_istream<_Elem, _Traits>& _Istr, let& obj) {

        /* 
            adjusted version of the std::string.operator>>(std::basic_istream) to  directly read characters into the string object and capture the conversion data.
        */
        //std::cout << "Begining the operator>>" << std::endl;
        using _Myis   = std::basic_istream<_Elem, _Traits>;
        using _Ctype  = typename _Myis::_Ctype;
        using _Mystr  = std::basic_string<_Elem, _Traits, std::allocator<_Elem>>;
        using _Mysizt = typename _Mystr::size_type;
        typename _Myis::iostate _State = _Myis::goodbit;

        bool _Changed                  = false;
        const typename _Myis::sentry _Ok(_Istr);
        enum _numeric_state { INT, DOUBLE, STRING } _nstate = _numeric_state::INT;
        auto& _Str = obj.data.str;
        if (_Ok) { // state okay, extract characters
            const _Ctype& _Ctype_fac = std::use_facet<_Ctype>(_Istr.getloc());
            if (obj._type == Type::String) {
                _Str.erase(); // clear the string
            } else {
                obj.str_constructor(); // it is not a string. Construct to string.
            }

            try { // TRY_IO_BEGIN
                _Mysizt _Size;
                if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {
                    _Size = static_cast<_Mysizt>(_Istr.width());
                } else {
                    _Size = _Str.max_size();
                }
                typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

                for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
                    if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                        _State |= _Myis::eofbit;
                        break;
                    } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                        break; // whitespace, quit
                    } else { // add character to string
                        _Changed = true;
                        if (_Meta == '.') {
                            if (_nstate == _numeric_state::INT) {
                                _nstate = _numeric_state::DOUBLE;
                            } else {
                                _nstate = _numeric_state::STRING;
                            }
                        } else if (!std::isdigit(_Meta)) {
                            _nstate = _numeric_state::STRING;
                        }

                        _Str.push_back(_Traits::to_char_type(_Meta));

                        if (_nstate == _numeric_state::STRING) {
                            for (--_Size, _Meta = _Istr.rdbuf()->snextc(); 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
                                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                                    _State |= _Myis::eofbit;
                                    break;
                                } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                                    break;
                                } else {
                                    _Str.push_back(_Traits::to_char_type(_Meta));
                                }
                            }
                            break;
                        }
                    }
                }
            } catch (...) { // _CATCH_IO_(_Myis, _Istr)
                std::cout << "error;" << std::endl;
                _Istr.setstate(_Myis::badbit, true);
            }
            
        }

        _Istr.width(0);
        if (!_Changed) {
            _State |= _Myis::failbit;
        }

        _Istr.setstate(_State);
        if (_nstate == _numeric_state::INT) {
            long long num = std::strtol(_Str.data(), nullptr, 10);
            obj.str_destructor();
            obj.data.num = num;
            obj._type = Type::Int;
        } else if (_nstate == _numeric_state::DOUBLE) {
            long double db = std::strtol(_Str.data(), nullptr, 10);
            obj.str_destructor();
            obj.data.fl = db;
            obj._type = Type::Double;
        } else {
            if (_Str == "true") {
                obj.str_destructor();
                obj.data.num = 1;
                obj._type = Type::Bool;
            } else if (_Str == "false") {
                obj.str_destructor();
                obj.data.num = 0;
                obj._type = Type::Bool;
            } else {
                obj._type = Type::String;
            }
        }
        return _Istr;

        // the below is the firstly written code
        // you may understand what does it do by this
        // the current implementation works a bit faster without optimization and generally faster (much or more) with optimization
        /*
            std::string s;
            _Istr >> s;
            if (s == "true") {
                obj = true;
            } else if (s == "false") {
                obj = false;
            } else {
                // try to convert into int
                auto ec = std::from_chars(s.data(), s.data() + s.size(), obj.data.num).ec;
                if (ec != std::errc()) {
                    // try to convert into double
                    double db;
                    if (!(std::istringstream(s) >> db)) {
                        // cannot convert into double, assigningn as string
                        obj = s;
                    }
                }
            }
        */
    }
};
namespace std {
    // template <class _Elem, class _Traits>
    // basic_istream<_Elem, _Traits>& getline(
    //     basic_istream<_Elem, _Traits>&& _Istr, let& _Obj) {
    //     // get characters into string, discard newline
    //     auto& _Str = _Obj.ref().str;
    //     if (_Obj.type() == Type::String) {
    //         _Str.erase();
    //     } else {
    //         _Obj = "";
    //     }
    //     std::getline(std::move(_Istr), _Str, _Istr.widen('\n'));
    //     if (_Str == "true") {
    //         _Obj = true;
    //     } else if (_Str == "false") {
    //         _Obj = false;
    //     } else {
    //         // try to convert into int
    //         long long num;
    //         auto ec = std::from_chars(_Str.data(), _Str.data() + _Str.size(), num).ec;
    //         if (ec == std::errc()) {
    //             _Obj = num;
    //         } else {
    //             // try to convert into double
    //             long double db;
    //             ec = std::from_chars(_Str.data(), _Str.data() + _Str.size(), db).ec;
    //             if (ec == std::errc()) {
    //                 // convertion success, assign the double
    //                 _Obj = db;
    //             }
    //         }
    //     }
    // }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& getline(
        basic_istream<_Elem, _Traits>& _Istr, let& _Obj, const _Elem _Delim) {
        // get characters into string, discard newline
        auto& _Str = _Obj.ref().str;
        if (_Obj.type() == Type::String) {
            _Str.erase();
        } else {
            _Obj = "";
        }
        std::getline(std::move(_Istr), _Str, _Delim);
        if (_Str == "true") {
            _Obj = true;
        } else if (_Str == "false") {
            _Obj = false;
        } else {
            // try to convert into int
            long long num;
            auto ec = std::from_chars(_Str.data(), _Str.data() + _Str.size(), num).ec;
            if (ec == std::errc()) {
                _Obj = num;
            } else {
                // try to convert into double
                long double db;
                ec = std::from_chars(_Str.data(), _Str.data() + _Str.size(), db).ec;
                if (ec == std::errc()) {
                    // convertion success, assign the double
                    _Obj = db;
                }
            }
        }
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& getline(
        basic_istream<_Elem, _Traits>& _Istr, let& _Obj) {
        // get characters into string, discard newline
        auto& _Str = _Obj.ref().str;
        if (_Obj.type() == Type::String) {
            _Str.erase();
        } else {
            _Obj = "";
        }
        std::getline(std::move(_Istr), _Str, _Istr.widen('\n'));
        if (_Str == "true") {
            _Obj = true;
        } else if (_Str == "false") {
            _Obj = false;
        } else {
            // try to convert into int
            long long num;
            auto ec = std::from_chars(_Str.data(), _Str.data() + _Str.size(), num).ec;
            if (ec == std::errc()) {
                _Obj = num;
            } else {
                // try to convert into double
                long double db;
                if (std::istringstream(_Str) >> db) {
                    // convertion success, assign the double
                    _Obj = db;
                }
            }
        }
        return _Istr;
    }

}
using std::getline;
Type::Type(const let& data) : _t(data.type()) {}
#endif // CPUF_LET